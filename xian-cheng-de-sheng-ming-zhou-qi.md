# 线程的生命周期
线程的生命周期：一个线程从创建到消亡的过程。（包括同步时的状态变化）

![](/assets/threadlifecycle.png)

### 创建状态（new）：
当用new操作符创建一个新的线程对象时，该线程处于创建状态。
处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。

### 可运行状态（就绪状态Runable）：
执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体——run()方法，这样就使得该线程处于可运行状态（Runnable）。这一状态并不是运行中状态（Running），因为线程也许实际上并未真正运行

### 运行状态（Running）：
就绪状态的线程获取了CPU，执行程序代码

### 阻塞状态（Blocked）：
阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    * 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，接着会进入锁池，竞争锁，再次获得对象锁才会进入运行状态
    * 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    * 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
    
### 死亡状态（Dead）：
线程执行完了或者因异常退出了run()方法，该线程结束生命周期

# speep（）和 wait()的区别

* 每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。**sleep()方法**正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(**注意：sleep方法只让出了CPU，而并不会释放同步资源锁，也就是不会释放同步资源！！！**)；**wait()方法**则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；
* sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；
* sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，**进入等待队列**，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，**才会进入锁池**，再次获得对象锁才会进入运行状态；
。
